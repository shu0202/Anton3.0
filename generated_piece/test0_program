%% File autogenerated by programBuilder.pl, part of the Anton composition system
%% Command line arguments : --task=compose --mode=major --time=10 --style=quartet

partTimeMax(P,10) :- part(P), P >= 1.
mode(major).
style(quartet).

%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% quartet.lp
%%
%% 13/05/09
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% Rules for composing / analysising melodies for a quartet

%% This is a quartet
style(quartet).

%% There are four parts
part(1..4).

%% The top part plays the melody
melodicPart(1).

%% For chords we need to know the lowest part
lowestPart(4).

%% We need a range of up to 2 octaves (24 steps) for each part,
%% thus need 24 notes above and below the lowest / highest start
#const quartetBottomNote=1.
#const quartetTopNote=68.
note(quartetBottomNote..quartetTopNote).
bottomNote(quartetBottomNote).
topNote(quartetTopNote).

%% Starting positions are 1 - 5 - 1 - 5
#const err_isn="Incorrect starting note".
reason(err_isn).
error(1,1,err_isn) :- not choosenNote(1,1,44).
error(2,1,err_isn) :- not choosenNote(2,1,37).
error(3,1,err_isn) :- not choosenNote(3,1,32).
error(4,1,err_isn) :- not choosenNote(4,1,25).

%% No rests
#const err_nrfw="No rest for the wicked".
reason(err_nrfw).
error(P,T,err_nrfw) :- rest(P,T).

%% With three or more parts allow intervals of a major fourth
%% (5 semitones) between parts
validInterval(5).


%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% notes.lp
%%
%% 13/05/09
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% General background rules on notes and intervals

%% Model in chromatic steps - 12 notes in an octave
%% needed for major and minor
chromaticPosition(1..12).
%#domain chromaticPosition(C).
%#domain chromaticPosition(C1).
%#domain chromaticPosition(C2).

%% The correspondance between number and note name is given by the key
%% and is applied at the synthesis step and is thus not modelled.
%% The number of notes depends on the style of the piece
%#domain note(N).
%#domain note(N1).
%#domain note(N2).

%% Map notes to their chromatic position
chromatic(N,N \ 12) :- note(N), (N \ 12) != 0.
chromatic(N,12) :- note(N), (N \ 12) == 0.

%% Intervals between notes are refered to as consonant if they are of a given distance:
%% unison (0), minor third (3), major third (4), fourth (5), perfect fifth (7) (mod 12)
consonantInterval(0).
consonantInterval(3).
consonantInterval(4).
consonantInterval(5).
consonantInterval(7).
%#domain consonantInterval(CI).

%% Pairs of chromatic positions that are consonant
consonant(C1,C2) :- note(N), chromatic(N,C1), chromatic(N + CI, C2), consonantInterval(CI), chromaticPosition(C1), chromaticPosition(C2).

%% The interval between two notes
%% Note there are two possible definitions of modulo distance
%% Thus it is important that the first chromatic position is
%% that of the higher note.
chromaticInterval(C1,C2,C1 - C2) :- chromaticPosition(C1), chromaticPosition(C2), C1 > C2.
chromaticInterval(C1,C2,(C1 + 12) - C2) :- chromaticPosition(C1), chromaticPosition(C2), C1 < C2.
chromaticInterval(C,C,0) :- chromaticPosition(C).

possibleChromaticInterval(0..11).
%#domain possibleChromaticInterval(D).


%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% modes.lp
%%
%% 29/03/07
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% A description of the various modes/keys the system can use

%% A mode is severn notes from the 12
%% (well, nine notes if it is a minor scale).
%% Must have one chromatic step between top of scale and fundamental.
%% Only pick from valid notes from mode.

%% mode is user defined.

% C major is C, D, E, F, G,  A,  B
% I.E.       1, 3, 5, 6, 8, 10, 12
modeChromaticPosition(1) :- mode(major).
modeChromaticPosition(3) :- mode(major).
modeChromaticPosition(5) :- mode(major).
modeChromaticPosition(6) :- mode(major).
modeChromaticPosition(8) :- mode(major).
modeChromaticPosition(10) :- mode(major).
modeChromaticPosition(12) :- mode(major).
lastChromaticPositionInMode(12) :- mode(major).

% C minor downwards is C, D, E^{\flat}, F, G, A^{\flat}, B^{\flat}, C
% I.E.                 1, 3, 4,         6, 8, 9,         11

% C minor upwards is C, D, E^{\flat}, F, G,  A,  B, C
% I.E.               1, 3, 4,         6, 8, 10, 12
modeChromaticPosition(1) :- mode(minor).
modeChromaticPosition(3) :- mode(minor).
modeChromaticPosition(4) :- mode(minor).
modeChromaticPosition(6) :- mode(minor).
modeChromaticPosition(8) :- mode(minor).
modeChromaticPosition(9) :- mode(minor).
modeChromaticPosition(10) :- mode(minor).
modeChromaticPosition(11) :- mode(minor).
modeChromaticPosition(12) :- mode(minor).
lastChromaticPositionInMode(11) :- mode(minor).
lastChromaticPositionInMode(12) :- mode(minor).


% The last two notes of a minor scale are dependant on direction
% upwards the last two are 10,12
% downwards the last two are 9,11
% You must be both progressing in the correct direction and continuing to
% progress in that directsion
#const err_imm="Invalid move in a minor key".
reason(err_imm).
error(P,T,err_imm) :- choosenChromatic(P,T,9), upAt(P,T - 1),
                      mode(minor), partTime(P,T - 1).
error(P,T,err_imm) :- choosenChromatic(P,T,11), upAt(P,T - 1),
                      mode(minor), partTime(P,T - 1).
error(P,T,err_imm) :- choosenChromatic(P,T,10), downAt(P,T - 1),
                      mode(minor), partTime(P,T - 1).
error(P,T,err_imm) :- choosenChromatic(P,T,12), downAt(P,T - 1),
                      mode(minor), partTime(P,T - 1).

error(P,T,err_imm) :- choosenChromatic(P,T,11), upAt(P,T), mode(minor).
error(P,T,err_imm) :- choosenChromatic(P,T,10), downAt(P,T), mode(minor).
error(P,T,err_imm) :- choosenChromatic(P,T,12), downAt(P,T), mode(minor).

%% 9 is an exception, you are allowed to move up, but not to 10 or 12
%error(P,T,err_imm) :- choosenChromatic(P,T,9), upAt(P,T), mode(minor).

error(P,T,err_imm) :- choosenChromatic(P,T,9), choosenChromatic(P,T+1,10), mode(minor).
error(P,T,err_imm) :- choosenChromatic(P,T,9), choosenChromatic(P,T+1,12), mode(minor).



%% Note that in some contexts C B C may be acceptable.
%%  B^{\flat} C B C is not one of them.


% Additionally, there are some restrictions
% Can't go from position (12,4), (10,4), (4,12), (4,10)
#const err_ijm="Invalid jump in a minor modeChromaticPosition".
reason(err_ijm).
error(P,T,err_ijm) :- choosenChromatic(P,T,12), choosenChromatic(P,T+1,4), mode(minor). 
error(P,T,err_ijm) :- choosenChromatic(P,T,10), choosenChromatic(P,T+1,4), mode(minor). 
error(P,T,err_ijm) :- choosenChromatic(P,T,4), choosenChromatic(P,T+1,10), mode(minor). 
error(P,T,err_ijm) :- choosenChromatic(P,T,4), choosenChromatic(P,T+1,12), mode(minor). 


% JPff suggests that B must also always resolve to C
#const err_mmmr="Problem with minor mode melodic resolution".
reason(err_mmmr).
error(P,T,err_mmmr) :- choosenChromatic(P,T,12), not choosenChromatic(P,T+1,1),
                       mode(minor), partTime(P,T+1).

% There are several restrictions on harmonic combinations in minor mode
% (12,9) = (12,21) and (12,4) = (12,16) aren't allowed
#const err_imh="Invalid minor harmonic combination".
reason(err_imh).
error(P1,T,err_imh) :- choosenChromatic(P1,T,12), choosenChromatic(P2,T,9), P1 < P2. 
error(P1,T,err_imh) :- choosenChromatic(P1,T,9), choosenChromatic(P2,T,12), P1 < P2. 
error(P1,T,err_imh) :- choosenChromatic(P1,T,12), choosenChromatic(P2,T,4), P1 < P2. 
error(P1,T,err_imh) :- choosenChromatic(P1,T,4), choosenChromatic(P2,T,12), P1 < P2.



% Dorian - white notes starting from D
% I.E.       1, 3, 4, 6, 8, 10, 11
modeChromaticPosition(1) :- mode(dorian).
modeChromaticPosition(3) :- mode(dorian).
modeChromaticPosition(4) :- mode(dorian).
modeChromaticPosition(6) :- mode(dorian).
modeChromaticPosition(8) :- mode(dorian).
modeChromaticPosition(10) :- mode(dorian).
modeChromaticPosition(11) :- mode(dorian).
lastChromaticPositionInMode(11) :- mode(dorian).


% Phrygian - white notes starting from E
% 1, 2, 4, 6, 8, 9, 11
modeChromaticPosition(1) :- mode(phrygian).
modeChromaticPosition(2) :- mode(phrygian).
modeChromaticPosition(4) :- mode(phrygian).
modeChromaticPosition(6) :- mode(phrygian).
modeChromaticPosition(8) :- mode(phrygian).
modeChromaticPosition(9) :- mode(phrygian).
modeChromaticPosition(11) :- mode(phrygian).
lastChromaticPositionInMode(11) :- mode(phrygian).

% Lydian F - F
% 1, 3, 5, 7, 8, 10, 12
modeChromaticPosition(1) :- mode(lydian).
modeChromaticPosition(3) :- mode(lydian).
modeChromaticPosition(5) :- mode(lydian).
modeChromaticPosition(7) :- mode(lydian).
modeChromaticPosition(8) :- mode(lydian).
modeChromaticPosition(10) :- mode(lydian).
modeChromaticPosition(12) :- mode(lydian).
lastChromaticPositionInMode(12) :- mode(lydian).


% Mixolydian G - G
% 1, 3, 5, 6, 8, 10, 11
modeChromaticPosition(1) :- mode(mixolydian).
modeChromaticPosition(3) :- mode(mixolydian).
modeChromaticPosition(5) :- mode(mixolydian).
modeChromaticPosition(6) :- mode(mixolydian).
modeChromaticPosition(8) :- mode(mixolydian).
modeChromaticPosition(10) :- mode(mixolydian).
modeChromaticPosition(11) :- mode(mixolydian).
lastChromaticPositionInMode(11) :- mode(mixolydian).

%% Every choosen note must be in the mode
#const err_nik="Choosen note not in mode".
reason(err_nik).
error(P,T,err_nik) :- chromaticPosition(C), choosenChromatic(P,T,C), not modeChromaticPosition(C). %tag


%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% progression.lp
%%
%% 03/11/06
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% Rules for the progression of all parts, melodic and harmonic

%% Note selection
%% may move by any reasonable amount (i.e. not just step)
%% are allowed the same note repeatedly


%% The number of parts is given by the style
%#domain part(P).
%#domain part(P1).
%#domain part(P2).


%% Time steps are given independantly for each part
partTime(P,1..TM) :- part(P), partTimeMax(P,TM). %changed

%% Each part can only play one note at a given time
%% This is needed so that partial pieces can be supplied.
 :- 2 { choosenNote(P,T,NN) : note(NN), rest(P,T) }, part(P), partTime(P,T). %tag

%% At every time step the note may change
%% It changes by stepping (moving one note in the scale)
%% or leaping (moving more than one note)
%% These can either be upwards or downwards
#count { 1:changes(P,T); 1:repeated(P,T);
    1:toRest(P,T); 1:fromRest(P,T);
    1:incorrectProgression(P,T) } = 1 :- part(P), partTime(P,T), partTimeMax(P,TM), T != TM. %changed
#count { 1:stepAt(P,T); 1:leapAt(P,T) } = 1 :- part(P), changes(P,T), partTimeMax(P,TM), T != TM. %changed
#count { 1:downAt(P,T);   1:upAt(P,T) } = 1 :- part(P), changes(P,T), partTimeMax(P,TM), T != TM. %changed

stepDown(P,T) :- part(P), stepAt(P,T), downAt(P,T). %changed
stepUp(P,T)   :- part(P), stepAt(P,T),   upAt(P,T). %changed

leapDown(P,T) :- part(P), leapAt(P,T), downAt(P,T). %changed
leapUp(P,T)   :- part(P), leapAt(P,T),   upAt(P,T). %changed

#const err_ip="Incorrect progression".
reason(err_ip).
error(P,T,err_ip) :- part(P), incorrectProgression(P,T). %changed

%% We start by moving from rest
fromRest(P,0) :- part(P).

%% Sanity checks so on the transition to and from rests
%% These are constraints rather than errors as fromRest / toRest
%% aren't part of the example format.
 :- rest(P,T), not repeated(P,T), not fromRest(P,T), part(P). %changed
 :- fromRest(P,T), not rest(P,T), T > 0, part(P). %changed


%% A step is to the next note of the mode
%% This assumes that for every given mode either N+1 or N+2 is in the mode
%% - but not both
%% Equivalently either N-1 or N-2 is in the mode
stepSize(2).
stepSize(1).
stepSize(-1).
stepSize(-2).
%#domain stepSize(S).
%#domain stepSize(S1).
%#domain stepSize(S2).
%#domain stepSize(S3).

%% If we step, we must pick an amount to step by
1 { stepBy(P,T,SS) : stepSize(SS), SS < 0 } 1 :- part(P), stepDown(P,T). %changed
1 { stepBy(P,T,SS) : stepSize(SS), SS > 0 } 1 :- part(P), stepUp(P,T). %changed
% (note that because of the structure of the mode
%  there should only be one option for each of these)

%% Leaps can only use consonant intervals
%% Connected - no jumps of over 12 chromatic steps
%% nor are dissonant leaps allowed (1), (6), (8), (9), (10), (11)
leapSize(CI) :- consonantInterval(CI), CI != 0.
leapSize(-CI) :- consonantInterval(CI), CI != 0.
leapSize(12).
leapSize(-12).
%#domain leapSize(L).
%#domain leapSize(L1).
%#domain leapSize(L2).
%#domain leapSize(L3).

%% If we leap then we must leap by a given amount
{ leapBy(P,T,LS) : leapSize(LS), LS < 0 } = 1 :- part(P), leapDown(P,T). %changed
{ leapBy(P,T,LS) : leapSize(LS), LS > 0 } = 1 :- part(P), leapUp(P,T). %changed


%% Make it so
choosenNote(P,T + 1,N + S) :- stepSize(S), part(P), choosenNote(P,T,N), stepAt(P,T),
                              stepBy(P,T,S), note(N + S). %changed
choosenNote(P,T + 1,N + L) :- leapSize(L), part(P), choosenNote(P,T,N), leapAt(P,T),
                              leapBy(P,T,L), note(N + L). %changed
choosenNote(P,T + 1,N) :- part(P), choosenNote(P,T,N), repeated(P,T). %changed

rest(P,T + 1) :- part(P), rest(P,T), repeated(P,T). %changed
rest(P,T + 1) :- part(P), toRest(P,T). %changed
1 { choosenNote(P,T + 1,NN) : note(NN) } 1 :- part(P), fromRest(P,T). %changed
1 { choosenNote(P,1,NN)     : note(NN) } 1 :- part(P), fromRest(P,0). %changed

%% In some cases we only care about the chromatic position of a part, not the note
choosenChromatic(P,T,C) :- note(N), part(P), chromaticPosition(C), choosenNote(P,T,N), chromatic(N,C). %changed


%% Notes must be within the given range
%% Note this is not an 'error' as it can only be given by the program
%% not the user (assuming piece inputs are just a set of notes)
%% plus having notes 'outside' the usual range cause problems
%% with multiple simmultaneous notes.
 :- stepSize(S), part(P), note(N), choosenNote(P,T,N), stepAt(P,T), stepBy(P,T,S), not note(N + S). %changed
 :- leapSize(L), part(P), note(N), choosenNote(P,T,N), leapAt(P,T), leapBy(P,T,L), not note(N + L). %changed


%% Work out the range of the part
notePlayed(P,N) :- part(P), note(N), choosenNote(P,T,N). %changed

highestNote(P,N) :- part(P), note(N), notePlayed(P,N), not lowerThanHighestNote(P,N). %changed
lowerThanHighestNote(P,N-1) :- part(P), note(N), highestNote(P,N). %changed
lowerThanHighestNote(P,N-1) :- part(P), note(N), lowerThanHighestNote(P,N). %changed

lowestNote(P,N) :- part(P), note(N), notePlayed(P,N), not higherThanLowestNote(P,N).
higherThanLowestNote(P,N+1) :- part(P), note(N), lowestNote(P,N).
higherThanLowestNote(P,N+1) :- part(P), note(N), higherThanLowestNote(P,N).


%% Total range must not be more than 2 octaves
#const err_ro="Range over two octaves".
reason(err_ro).
error(P,TM,err_ro) :- part(P), note(N1), note(N2), lowestNote(P,N1), highestNote(P,N2), N1 + 24 < N2, partTimeMax(P,TM). %changed



%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% melody.lp
%%
%% 03/11/06
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% The rules for melodic parts


%% These rules only apply to melodic parts
%#domain melodicPart(MP).

%% Melodic parts are not allowed to repeat notes
#const err_nrmp="No repeated notes in melodic parts".
reason(err_nrmp).
error(MP,T,err_nrmp) :- melodicPart(MP), repeated(MP,T). %changed


%% Last interval is major or minor second (respectively two or one step)
%% I.E. It cannot be a leap
#const err_lins="Last interval is not a second".
reason(err_lins).
error(MP,TM-1,err_lins) :- melodicPart(MP), leapAt(MP,TM-1), partTimeMax(MP,TM). %changed


%% A leap of an octave is only allowed from the fundamental.
#const err_olnf="Leap of an octave from a note other than the fundamental".
reason(err_olnf).
error(MP,T,err_olnf) :- melodicPart(MP), leapBy(MP,T,12), not choosenChromatic(MP,T,1). %changed
error(MP,T,err_olnf) :- melodicPart(MP), leapBy(MP,T,-12), not choosenChromatic(MP,T,1). %changed


%% No two consecutive jumps that `cancel'
#const err_cl="Leaps cancel".
reason(err_cl).
error(MP,T,err_cl) :- melodicPart(MP),leapSize(L), leapBy(MP,T,L), leapBy(MP,T + 1,-L), partTime(MP,T+1). %changed


%% Dissonant contour
%% distance between lowest and highest note of melody - should not be a dissonant interval
#const err_dc="Dissonant contour".
reason(err_dc).
error(MP,TM,err_dc) :-  melodicPart(MP), note(N1), note(N2), chromaticPosition(C1), chromaticPosition(C2), lowestNote(MP,N1), highestNote(MP,N2),
                       chromatic(N1,C1),  chromatic(N2,C2),
                       not consonant(C1,C2), N1 < N2, partTimeMax(MP,TM). %changed



%% No tri-tones
%% A tritone occurs when a pair of notes, one time step apart differ
%% in tone by 6 semitones.
#const err_tt="Tri-tone".
reason(err_tt).
error(MP,T,err_tt) :- melodicPart(MP), note(N1), choosenNote(MP,T,N1), choosenNote(MP,T+2,N1+6).
error(MP,T,err_tt) :- melodicPart(MP), note(N1), choosenNote(MP,T,N1), choosenNote(MP,T+2,N1-6).





%% Impulse
%% Stepwise linear progression creates impulse
%% Leaps create impulse - using the notes inbetween resolves this
downwardImpulse(MP,T+1) :- melodicPart(MP), leapDown(MP,T), partTime(MP,T+1). %changed
downwardImpulse(MP,T+3) :- melodicPart(MP), stepDown(MP,T+2), stepDown(MP,T+1),
                           stepDown(MP,T), partTime(MP,T+3). %changed

upwardImpulse(MP,T+1) :- melodicPart(MP), leapUp(MP,T), partTime(MP,T+1). %changed
upwardImpulse(MP,T+3) :- melodicPart(MP), stepUp(MP,T+2), stepUp(MP,T+1),
                         stepUp(MP,T), partTime(MP,T+3). %changed


%% Resolution is in the oppersite direction to impulse
#const err_inr="Impulse not resolved".
reason(err_inr).
error(MP,T,err_inr) :- melodicPart(MP), downwardImpulse(MP,T), downAt(MP,T). %changed
error(MP,T,err_inr) :- melodicPart(MP), upwardImpulse(MP,T), upAt(MP,T). %changed


%% After a leap must use everything inbetween 
%% can jump again but it must be inside the range
#const err_ns="Note skipped".
reason(err_ns).
error(MP,TM,err_ns) :-  melodicPart(MP), note(N), chromaticPosition(C), not notePlayed(MP,N),
                        lowerThanHighestNote(MP,N), higherThanLowestNote(MP,N),
                        chromatic(N,C), modeChromaticPosition(C),
                        partTimeMax(P,TM).




%% We have a window in which repetition isn't allowed
repetitionWindow(8).
%#domain repetitionWindow(RW).

%% Shouldn't repeat simple patterns of progression
%% (things in mode) 0 - 2 - 1, 1 - 3 - 2, 
%% A pattern is a minimum of 3 notes and a maximum of melodyLength/2 notes
#const err_rp="Repeated pattern".
reason(err_rp).
error(MP,T1,err_rp) :- melodicPart(MP), stepSize(S1), stepSize(S2), stepBy(MP,T1,S1), stepBy(MP,T1 + 1,S2),
                       stepBy(MP,T2,S1), stepBy(MP,T2 + 1,S2),
                       T1 + 1 < T2, T2 < T1 + 2 + RW, repetitionWindow(RW). %changed
error(MP,T1,err_rp) :- melodicPart(MP), stepSize(S1), leapSize(L2), stepBy(MP,T1,S1), leapBy(MP,T1 + 1,L2),
                       stepBy(MP,T2,S1), leapBy(MP,T2 + 1,L2),
                       T1 + 1 < T2, T2 < T1 + 2 + RW, repetitionWindow(RW). %changed
error(MP,T1,err_rp) :- melodicPart(MP), leapSize(L1), stepSize(S2), leapBy(MP,T1,L1), stepBy(MP,T1 + 1,S2),
                       leapBy(MP,T2,L1), stepBy(MP,T2 + 1,S2),
                       T1 + 1 < T2, T2 < T1 + 2 + RW, repetitionWindow(RW). %changed
error(MP,T1,err_rp) :- melodicPart(MP), leapSize(L1), leapSize(L2), leapBy(MP,T1,L1), leapBy(MP,T1 + 1,L2),
                       leapBy(MP,T2,L1), leapBy(MP,T2 + 1,L2),
                       T1 + 1 < T2, T2 < T1 + 2 + RW, repetitionWindow(RW). %changed


%% No repetition of two or more notes
#const err_rn="Repeated notes".
reason(err_rn).

error(MP,T1,err_rn) :- melodicPart(MP), stepSize(S1), choosenNote(MP,T1,N), stepBy(MP,T1,S1),
                       choosenNote(MP,T2,N), stepBy(MP,T2,S1),
                       T1 + 1 < T2, T2 < T1 + 2 + RW, repetitionWindow(RW). %changed
error(MP,T1,err_rn) :- melodicPart(MP), note(N), choosenNote(MP,T1,N), leapBy(MP,T1,L1),
                       choosenNote(MP,T2,N), leapBy(MP,T2,L1),
                       T1 + 1 < T2, T2 < T1 + 2 + RW, repetitionWindow(RW). %changed


%% Split melodies occur when the even / odd notes form separate melodies.
%% A leap (in the same direction) are not allowed to be repeated at T+2.
%% Steps are only allowed if the intermediate movement is not a step
%% in the oppersite direction.
#const err_sm="Split melody".
reason(err_sm).

error(MP,T,err_sm) :- melodicPart(MP), leapSize(L), leapBy(MP,T,L), leapBy(MP,T+2,L). %changed
error(MP,T,err_sm) :- melodicPart(MP), stepSize(S1), stepSize(S2), stepBy(MP,T,S1), stepBy(MP,T+1,S2), stepBy(MP,T+2,S1),
                      S1 > 0, S2 < 0. %changed
error(MP,T,err_sm) :- melodicPart(MP), stepSize(S1), stepSize(S2), stepBy(MP,T,S1), stepBy(MP,T+1,S2), stepBy(MP,T+2,S1),
                      S1 < 0, S2 > 0. %changed

%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% harmony.lp
%%
%% 31/03/07
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% Rules for working with multiple parts.
%% Every rule should be predicated so that if there is only one part, they won't be generated



%% The only allowed intervals between parts are consonant intervals (but not the major fourth (5))
%% plus minor and major sixth (8/9) and 15/16 major and minor third over the octave
validInterval(CI) :- consonantInterval(CI), CI != 5. %changed
validInterval(8).
validInterval(9).
validInterval(12).
validInterval(15).
validInterval(16).


%% To simplify instantiation of a few rules, we infer which octave
%% a part is playing in at each given time
%noteOctave(N,O) :- note(N), chromatic(N,C), O = (N - C) / 12.
%choosenOctave(P,T,O) :- choosenNote(P,T,N), noteOctave(N,O).
%% The octave based encoding seems to save about 35% of program size but is slower

#const err_dibp="Dissonant interval between parts".
reason(err_dibp).
error(P1,T1,err_dibp) :- part(P1), part(P2), chromaticPosition(C1), chromaticPosition(C2), choosenChromatic(P1,T1,C1), choosenChromatic(P2,T2,C2),
                         P1 < P2, chromaticInterval(C1,C2,D), not validInterval(D),
                         noteOverlap(P1,T1,P2,T2). %changed
                        


%% The maximum distance between parts is an octave plus 4 semitones (i.e. 16 semitones).
#const err_mdbp="Over maximum distance between parts".
reason(err_mdbp).
error(P,T1,err_mdbp) :- part(P), note(N2), note(N1), choosenNote(P,T1,N1), choosenNote(P+1,T2,N2),
                        N1 > N2 + 16, part(P+1), noteOverlap(P,T1,P+1,T2). %changed

% Alternative, octave based enocding
%error(P,T1,err_mdbp) :- choosenOctave(P,T1,O1), choosenOctave(P+1,T2,O2),
%                        O1 > O2 + 2, part(P+1), noteOverlap(P,T1,P+1,T2).
%error(P,T1,err_mdbp) :- choosenOctave(P,T1,O+1), choosenOctave(P+1,T2,O),
%			choosenNote(P,T1,N1), choosenNote(P+1,T2,N2),
%			noteOctave(N1,O+2), noteOctave(N2,O),
%                        N1 > N2 + 16, part(P+1), noteOverlap(P,T1,P+1,T2).
%error(P,T1,err_mdbp) :- choosenOctave(P,T1,O+1), choosenOctave(P+1,T2,O),
%			choosenNote(P,T1,N1), choosenNote(P+1,T2,N2),
%			noteOctave(N1,O+1), noteOctave(N2,O),
%                        N1 > N2 + 16, part(P+1), noteOverlap(P,T1,P+1,T2).


%% Parts can't cross over.
#const err_pcc="Parts can not cross".
reason(err_pcc).
error(P,T1,err_pcc) :- part(P), note(N2), note(N1), choosenNote(P,T1,N1), choosenNote(P+1,T2,N2),
                       N1 < N2, part(P+1), noteOverlap(P,T1,P+1,T2). %changed


%% Parts can only ever meet at a single point, and this can only happen once.
%% P+1 is OK, because for P,P+N (N>1) to meet have to have P,P+1 meet.
unison(P1,P2,T1) :- part(P1), part(P2), choosenNote(P1,T1,N), choosenNote(P2,T2,N), P1 < P2, noteOverlap(P1,T1,P2,T2). %changed
haveMet(P,T+1) :- part(P), unison(P,P+1,T), not haveMet(P,T), part(P+1), partTime(P,T). %changed
haveMet(P,T+1) :- part(P), haveMet(P,T), partTime(P,T). %changed

#const err_cmmt="Parts can not meet multiple times".
reason(err_cmmt).
error(P,T,err_cmmt) :- part(P), unison(P,P+1,T), haveMet(P,T), part(P+1). %chnaged


%% If one voice leaps, neighbouring parts must step or leap
%% in the oppersite direction
#const err_nspj="No simultaneous parallel leaps".
reason(err_nspj).
error(P2,T1,err_nspj) :- part(P1), part(P2), leapDown(P1,T1), downAt(P2,T2),
                        P1-1 <= P2, P2 <= P1+1, P1 != P2,
                        noteOverlap(P1,T1,P2,T2). %changed
error(P2,T1,err_nspj) :-   part(P1), part(P2), leapUp(P1,T1),   upAt(P2,T2),
                        P1-1 <= P2, P2 <= P1+1, P1 != P2,
                        noteOverlap(P1,T1,P2,T2). %changed

%% Two parts shouldn't leap to the same chromatic position
#const err_ltscp="Leap to same chromatic position".
reason(err_ltscp).

error(P1,T1,err_ltscp) :- part(P1), part(P2), choosenChromatic(P1,T1,C), choosenChromatic(P2,T2,C),
                          leapAt(P1,T1-1), leapAt(P2,T2-1), P1 < P2,
                          noteOverlap(P1,T1,P2,T2). %changed

%% Two parts shouldn't leap by the same amount in the same direction
#const err_plsi="Parallel leap by the same interval".
reason(err_plsi).

error(P1,T1,err_plsi) :- part(P1), part(P2), leapBy(P1,T1,L), leapBy(P2,T2,L), P1 < P2, noteOverlap(P1,T1,P2,T2). %chnaged


%% No sequences of perfect fifths or perfect octaves
#const err_rpf="Repeated perfect fifth".
reason(err_rpf).
perfectFifth(P1,P2,T1) :- part(P1), part(P2), choosenChromatic(P1,T1,C1), choosenChromatic(P2,T2,C2),
                          chromaticInterval(C1,C2,7), P1 < P2,
                          noteOverlap(P1,T1,P2,T2). %changed
error(P1,T,err_rpf) :- part(P1), part(P2), perfectFifth(P1,P2,T), perfectFifth(P1,P2,T+1),
                       P1 < P2,  partTime(P1,T+1). %changed


% If two parts play in unison, we don't want this identified as a perfectOctave
#const err_rpo="Repeated perfect octave".
reason(err_rpo).
perfectOctave(P1,P2,T1) :- part(P1), part(P2), choosenChromatic(P1,T1,C1), choosenChromatic(P2,T2,C2),
                           chromaticInterval(C1,C2,0), P1 < P2, not unison(P1,P2,T1),
                           noteOverlap(P1,T1,P2,T2). %changed
error(P1,T,err_rpo) :- part(P1), part(P2),  perfectOctave(P1,P2,T), perfectOctave(P1,P2,T+1),
                       P1 < P2,  partTime(P1,T+1). %changed




%% The same consonant interval can be repeated at most three times
%% (notes as well as semitone intervals)
#const err_qci="Consonant interval repeated more than three times".
reason(err_qci).

partChromaticInterval(P,P+1,T1,D) :- part(P), chromaticPosition(C1), chromaticPosition(C2), choosenChromatic(P,T1,C1),
                                    choosenChromatic(P+1,T2,C2),
                                    chromaticInterval(C1,C2,D),
                                    part(P+1),
                                    noteOverlap(P,T1,P+1,T2). %changed

error(P,T,err_qci) :- part(P), possibleChromaticInterval(D), partChromaticInterval(P,P+1,T,D),
		      partChromaticInterval(P,P+1,T+1,D),
		      partChromaticInterval(P,P+1,T+2,D),
		      partChromaticInterval(P,P+1,T+3,D),
                      partTime(P,T+3). %changed


%% Should never have two parts playing the last note of the scale together
#const err_rlns="Repeated last note of scale".
reason(err_rlns).

error(P1,T1,err_rlns) :- part(P1), part(P2), chromaticPosition(C1), chromaticPosition(C2), choosenChromatic(P1,T1,C1), choosenChromatic(P2,T2,C2),
                        lastChromaticPositionInMode(C1),
                        lastChromaticPositionInMode(C2),
                        P1 < P2, noteOverlap(P1,T1,P2,T2). %changed



%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% chord.lp
%%
%% 19/05/09
%%
%% Concepts by John ffitch, jpff@cs.bath.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% Description of chords and chordal progression

%% Let the parser know we are generating chords
chordal(1) :- mode(major).
chordal(1) :- mode(minor).

%% A major chord is (4,3,5) - i.e. C,E,G
%% A minor chord is (3,4,5) - i.e. C,E^{\flat},G
chordOffset(0).
chordOffset(3) :- mode(minor).
chordOffset(4) :- mode(major).
chordOffset(7).

%% There are three triads
triad("tonic").             % Based on the fundamental
triad("dominant").          % Based a 5th / 7 semitones above fundamental
triad("subdominant").       % Based a 5th / 7 semitones below fundamental
%#domain triad(TR).


%% Each triad contains three chromatic positions
triadPosition("base").
triadPosition("middle").
triadPosition("top").
%#domain triadPosition(TP).

triadMember("tonic","base",1).
triadMember("dominant","base",8).
triadMember("subdominant","base",6).

triadMember(TR,"middle",C+3)      :- triad(TR), chromaticPosition(C), triadMember(TR,"base",C), mode(minor), C+3 <= 12. %changed
triadMember(TR,"middle",(C+3)-12) :- triad(TR), chromaticPosition(C), triadMember(TR,"base",C), mode(minor), C+3 >  12. %changed
triadMember(TR,"middle",C+4)      :- triad(TR), chromaticPosition(C), triadMember(TR,"base",C), mode(major), C+4 <= 12. %changed
triadMember(TR,"middle",(C+4)-12) :- triad(TR), chromaticPosition(C), triadMember(TR,"base",C), mode(major), C+4 >  12. %changed

triadMember(TR,"top",C+7)      :- triad(TR), chromaticPosition(C), triadMember(TR,"base",C), C+7 <= 12. %changed
triadMember(TR,"top",(C+7)-12) :- triad(TR), chromaticPosition(C), triadMember(TR,"base",C), C+7 >  12. %changed


%% Thus in C major there are three triads
%% Tonic         C - E - G  (The main one)
%% Dominant      G - B - D
%% Subdominant   F - A - C

%% Note when a part if playing part of a triad
partPlaysInTriad(PC,P,TR,TP) :- triadPosition(TP), triad(TR), chromaticPosition(C), possibleChord(PC), triadMember(TR,TP,C),
			        noteInPossibleChord(P,T,PC), choosenChromatic(P,T,C). %changed

%% A part is playing in the triad if it plays any position
inTriad(PC,P,TR) :- triad(TR), chromaticPosition(C), possibleChord(PC), part(P), triad(TR),
		    1 {partPlaysInTriad(PC,P,TR,TPP) : triadPosition(TPP) }. %changed

%% And a position is played if any part plays it
triadPartPlayed(PC,TR,TP) :- triad(TR), possibleChord(PC), triad(TR), triadPosition(TP),
			     1 {partPlaysInTriad(PC,PP,TR,TP) : part(PP)}. %chnaged

%% If all of the part are playing a given triad and
%% every part of that triad is being played, then we have that chord
chord(PC,TR) :- triad(TR), possibleChord(PC), 
                inTriad(PC,PP,TR), part(PP),
                triadPartPlayed(PC,TR,TPP), triadPosition(TPP). %changed


%% Any chord has three positions
%% Lowest note in the chord gives the position
%% 1st note is lowest - base position
%% 2nd note is lowest - first inversion
%% 3rd note is lowest - second inversion

chordPosition(PC,"base") :- triad(TR), chord(PC,TR), lowestPart(LP),
			    partPlaysInTriad(PC,LP,TR,"base"). %changed
chordPosition(PC,"first inversion") :- triad(TR), chord(PC,TR), lowestPart(LP),
			    partPlaysInTriad(PC,LP,TR,"middle"). %changed
chordPosition(PC,"second inversion") :- triad(TR), chord(PC,TR), lowestPart(LP),
			    partPlaysInTriad(PC,LP,TR,"top"). %changed



%% A cadence is a pair of chords successive chord
cadence(PC2,"perfect") :- chord(PC1,"dominant"), chord(PC2,"tonic"),
		          possibleChord(PC1), possibleChord(PC2),
			  nextPossibleChord(PC1,PC2), PC1 < PC2.
cadence(PC2,"plagual") :- chord(PC1,"subdominant"), chord(PC2,"tonic"),
		          possibleChord(PC1), possibleChord(PC2),
			  nextPossibleChord(PC1,PC2), PC1 < PC2.
cadence(PC2,"imperfect") :- chord(PC1,"tonic"), chord(PC2,"dominant"),
		          possibleChord(PC1), possibleChord(PC2),
			  nextPossibleChord(PC1,PC2), PC1 < PC2.


%% Resolution
%% Second inversion is a special case, has to resolve to base position
%%  subdominant -> tonic
%%  tonic -> dominant
#const err_cnr="Chord not resolved".
reason(err_cnr).

error(LP,TM,err_cnr) :- chordPosition(PC1,"second inversion"),
		        not chordPosition(PC2,"base"),
		        possibleChord(PC1), possibleChord(PC2),
		        nextPossibleChord(PC1,PC2), PC1 < PC2,
		        lowestPart(LP), partTimeMax(LP,TM), chordal(1).

error(LP,TM,err_cnr) :- chordPosition(PC1,"second inversion"),
		        chord(PC1,"subdominant"),
                        not chord(PC2,"tonic"),
		        possibleChord(PC1), possibleChord(PC2),
		        nextPossibleChord(PC1,PC2), PC1 < PC2,
		        lowestPart(LP), partTimeMax(LP,TM), chordal(1).

error(LP,TM,err_cnr) :- chordPosition(PC1,"second inversion"),
		        chord(PC1,"tonic"),
                        not chord(PC2,"dominant"),
		        possibleChord(PC1), possibleChord(PC2),
		        nextPossibleChord(PC1,PC2), PC1 < PC2,
		        lowestPart(LP), partTimeMax(LP,TM), chordal(1).


%% Middle note of the triad is strong, so shouldn't be doubled
#const err_mntd="Middle note of triad doubled".
reason(err_mntd).
error(LP,TM,err_mntd) :- 2 { partPlaysInTriad(PC,PP,TR,"middle") : part(PP) }, triad(TR), 
                        chord(PC,TR), lowestPart(LP), partTimeMax(LP,TM), chordal(1). %changed


%% Final notes must form a tonic chord
#const err_fnntc="Final note not a tonic chord".
reason(err_fnntc).
error(LP,TM,err_fnntc) :- not chord(PC,"tonic"), lastPossibleChord(PC),
		          lowestPart(LP), partTimeMax(LP,TM), chordal(1).


%% And it must be in base position
#const err_fcnbp="Final chord not in base position".
reason(err_fcnbp).
error(LP,TM,err_fcnbp) :- not chordPosition(PC,"base"), lastPossibleChord(PC),
		          lowestPart(LP), partTimeMax(LP,TM), chordal(1).





%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% monorhythmic.lp
%%
%% 02/02/10
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% If the rhythm option is not used, this gives default definitions
%% of rhythmic concepts.

rhythm(0).
%% Parts overlap if their timesteps match
noteOverlap(P1,T,P2,T) :- part(P1), part(P2), not rhythm(1), P1 != P2,
                          partTime(P1,T), partTime(P2,T).

%% Every time step is a possible chord
possibleChord(PC) :- part(P), partTime(P,PC).

%% Thus the progression is obvious
nextPossibleChord(PC,PC+1) :- possibleChord(PC), possibleChord(PC+1).
lastPossibleChord(PC) :- not possibleChord(PC+1), possibleChord(PC).

%% With the corresponding notes in each chord
noteInPossibleChord(P,PC,PC) :- part(P), partTime(P,PC), possibleChord(PC).



%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% compose.lp
%%
%% Martin Brain
%% mjb@cs.bath.ac.uk
%% 27/03/08
%%
%% Uses the melodic and harmonic rules to generate valid pieces of music

%#hide.

mode(K) :- mode(K).
#show mode/1.

% #show style(C).
style(C) :- style(C).
#show style/1.

% #show part(P).
part(P) :- part(P).
#show part/1.

% #show partTime(P,T).
partTime(P,T) :- partTime(P,T).
#show partTime/2.
% #show partTimeMax(P,TM).
partTimeMax(P,TM) :- partTimeMax(P,TM).
#show partTimeMax/2.

% #show choosenNote(P,T,N).
choosenNote(P,T,N) :- choosenNote(P,T,N).
#show choosenNote/3.
% #show rest(P,T).
rest(P,T) :- rest(P,T).
#show rest/2.

% #show leapBy(P,T,L).
leapBy(P,T,L) :- leapBy(P,T,L).
#show leapBy/3.
% #show stepBy(P,T,S).
stepBy(P,T,S) :- stepBy(P,T,S).
#show stepBy/3.
% #show repeated(P,T).
repeated(P,T) :- repeated(P,T).
#show repeated/2.
% #show incorrectProgression(P,T).
incorrectProgression(P,T) :- incorrectProgression(P,T).
#show incorrectProgression/2.
% #show toRest(P,T).
toRest(P,T) :- toRest(P,T).
#show toRest/2.
% #show fromRest(P,T).
fromRest(P,T) :- fromRest(P,T).
#show fromRest/2.

% #show chordal(B).
chordal(B) :- chordal(B).
#show chordal/1.
% #show chord(T,TR).
chord(T,TR) :- chord(T,TR).
#show chord/2.
% #show chordPosition(T,TP).
chordPosition(T,TP) :- chordPosition(T,TP).
#show chordPosition/2.
% #show cadence(T,C).
cadence(T,C) :- cadence(T,C).
#show cadence/2.

% No errors are allowed
% #domain reason(R).
  :- reason(R), error(P,T,R).