%% File autogenerated by programBuilder.pl, part of the Anton composition system
%% Command line arguments : --task=compose --mode=major --time=10 --style=solo

partTimeMax(P,10) :- part(P), P >= 1.
mode(major).
style(solo).

%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% solo.lp
%%
%% 29/03/07
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% Rules for composing / analysising melodies for a single instrument

%% This is a solo
style(solo).

%% There is only one part...
part(1).

%% ... and it is melodic
melodicPart(1).

%% We need a range of up to 2 octaves (24 steps), thus need 24 notes above and below the start / end
#const soloBottomNote=1.
#const soloTopNote=49.
note(soloBottomNote..soloTopNote).
bottomNote(soloBottomNote).
topNote(soloTopNote).

%% Start on the (middle) fundamental, a 5th above or a 5th below
%% (5 chromatic steps down or 7 up) ...
#const err_isn="Incorrect starting note".
reason(err_isn).
error(1,1,err_isn) :- not choosenNote(1,1,20), not choosenNote(1,1,25),
                      not choosenNote(1,1,32).

%% ... and finish on the fundamental
#const err_snff="Must finish on the fundamental".
reason(err_snff).
error(1,TM,err_snff) :- choosenNote(1,TM,N), chromatic(N,C), C != 1,
                       partTimeMax(1,TM).

%% No rests
#const err_nrfw="No rest for the wicked".
reason(err_nrfw).
error(P,T,err_nrfw) :- rest(P,T).



%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% notes.lp
%%
%% 13/05/09
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% General background rules on notes and intervals

%% Model in chromatic steps - 12 notes in an octave
%% needed for major and minor
chromaticPosition(1..12).
%#domain chromaticPosition(C).
%#domain chromaticPosition(C1).
%#domain chromaticPosition(C2).

%% The correspondance between number and note name is given by the key
%% and is applied at the synthesis step and is thus not modelled.
%% The number of notes depends on the style of the piece
%#domain note(N).
%#domain note(N1).
%#domain note(N2).

%% Map notes to their chromatic position
chromatic(N,N \ 12) :- note(N), (N \ 12) != 0.
chromatic(N,12) :- note(N), (N \ 12) == 0.

%% Intervals between notes are refered to as consonant if they are of a given distance:
%% unison (0), minor third (3), major third (4), fourth (5), perfect fifth (7) (mod 12)
consonantInterval(0).
consonantInterval(3).
consonantInterval(4).
consonantInterval(5).
consonantInterval(7).
%#domain consonantInterval(CI).

%% Pairs of chromatic positions that are consonant
consonant(C1,C2) :- chromatic(N,C1), chromatic(N + CI, C2), consonantInterval(CI), chromaticPosition(C1), chromaticPosition(C2).

%% The interval between two notes
%% Note there are two possible definitions of modulo distance
%% Thus it is important that the first chromatic position is
%% that of the higher note.
chromaticInterval(C1,C2,C1 - C2) :- chromaticPosition(C1), chromaticPosition(C2), C1 > C2.
chromaticInterval(C1,C2,(C1 + 12) - C2) :- chromaticPosition(C1), chromaticPosition(C2), C1 < C2.
chromaticInterval(C,C,0) :- chromaticPosition(C).

possibleChromaticInterval(0..11).
%#domain possibleChromaticInterval(D).


%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% modes.lp
%%
%% 29/03/07
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% A description of the various modes/keys the system can use

%% A mode is severn notes from the 12
%% (well, nine notes if it is a minor scale).
%% Must have one chromatic step between top of scale and fundamental.
%% Only pick from valid notes from mode.

%% mode is user defined.

% C major is C, D, E, F, G,  A,  B
% I.E.       1, 3, 5, 6, 8, 10, 12
modeChromaticPosition(1) :- mode(major).
modeChromaticPosition(3) :- mode(major).
modeChromaticPosition(5) :- mode(major).
modeChromaticPosition(6) :- mode(major).
modeChromaticPosition(8) :- mode(major).
modeChromaticPosition(10) :- mode(major).
modeChromaticPosition(12) :- mode(major).
lastChromaticPositionInMode(12) :- mode(major).

% C minor downwards is C, D, E^{\flat}, F, G, A^{\flat}, B^{\flat}, C
% I.E.                 1, 3, 4,         6, 8, 9,         11

% C minor upwards is C, D, E^{\flat}, F, G,  A,  B, C
% I.E.               1, 3, 4,         6, 8, 10, 12
modeChromaticPosition(1) :- mode(minor).
modeChromaticPosition(3) :- mode(minor).
modeChromaticPosition(4) :- mode(minor).
modeChromaticPosition(6) :- mode(minor).
modeChromaticPosition(8) :- mode(minor).
modeChromaticPosition(9) :- mode(minor).
modeChromaticPosition(10) :- mode(minor).
modeChromaticPosition(11) :- mode(minor).
modeChromaticPosition(12) :- mode(minor).
lastChromaticPositionInMode(11) :- mode(minor).
lastChromaticPositionInMode(12) :- mode(minor).


% The last two notes of a minor scale are dependant on direction
% upwards the last two are 10,12
% downwards the last two are 9,11
% You must be both progressing in the correct direction and continuing to
% progress in that directsion
#const err_imm="Invalid move in a minor key".
reason(err_imm).
error(P,T,err_imm) :- choosenChromatic(P,T,9), upAt(P,T - 1),
                      mode(minor), partTime(P,T - 1).
error(P,T,err_imm) :- choosenChromatic(P,T,11), upAt(P,T - 1),
                      mode(minor), partTime(P,T - 1).
error(P,T,err_imm) :- choosenChromatic(P,T,10), downAt(P,T - 1),
                      mode(minor), partTime(P,T - 1).
error(P,T,err_imm) :- choosenChromatic(P,T,12), downAt(P,T - 1),
                      mode(minor), partTime(P,T - 1).

error(P,T,err_imm) :- choosenChromatic(P,T,11), upAt(P,T), mode(minor).
error(P,T,err_imm) :- choosenChromatic(P,T,10), downAt(P,T), mode(minor).
error(P,T,err_imm) :- choosenChromatic(P,T,12), downAt(P,T), mode(minor).

%% 9 is an exception, you are allowed to move up, but not to 10 or 12
%error(P,T,err_imm) :- choosenChromatic(P,T,9), upAt(P,T), mode(minor).

error(P,T,err_imm) :- choosenChromatic(P,T,9), choosenChromatic(P,T+1,10), mode(minor).
error(P,T,err_imm) :- choosenChromatic(P,T,9), choosenChromatic(P,T+1,12), mode(minor).



%% Note that in some contexts C B C may be acceptable.
%%  B^{\flat} C B C is not one of them.


% Additionally, there are some restrictions
% Can't go from position (12,4), (10,4), (4,12), (4,10)
#const err_ijm="Invalid jump in a minor modeChromaticPosition".
reason(err_ijm).
error(P,T,err_ijm) :- choosenChromatic(P,T,12), choosenChromatic(P,T+1,4), mode(minor). 
error(P,T,err_ijm) :- choosenChromatic(P,T,10), choosenChromatic(P,T+1,4), mode(minor). 
error(P,T,err_ijm) :- choosenChromatic(P,T,4), choosenChromatic(P,T+1,10), mode(minor). 
error(P,T,err_ijm) :- choosenChromatic(P,T,4), choosenChromatic(P,T+1,12), mode(minor). 


% JPff suggests that B must also always resolve to C
#const err_mmmr="Problem with minor mode melodic resolution".
reason(err_mmmr).
error(P,T,err_mmmr) :- choosenChromatic(P,T,12), not choosenChromatic(P,T+1,1),
                       mode(minor), partTime(P,T+1).

% There are several restrictions on harmonic combinations in minor mode
% (12,9) = (12,21) and (12,4) = (12,16) aren't allowed
#const err_imh="Invalid minor harmonic combination".
reason(err_imh).
error(P1,T,err_imh) :- choosenChromatic(P1,T,12), choosenChromatic(P2,T,9), P1 < P2. 
error(P1,T,err_imh) :- choosenChromatic(P1,T,9), choosenChromatic(P2,T,12), P1 < P2. 
error(P1,T,err_imh) :- choosenChromatic(P1,T,12), choosenChromatic(P2,T,4), P1 < P2. 
error(P1,T,err_imh) :- choosenChromatic(P1,T,4), choosenChromatic(P2,T,12), P1 < P2.



% Dorian - white notes starting from D
% I.E.       1, 3, 4, 6, 8, 10, 11
modeChromaticPosition(1) :- mode(dorian).
modeChromaticPosition(3) :- mode(dorian).
modeChromaticPosition(4) :- mode(dorian).
modeChromaticPosition(6) :- mode(dorian).
modeChromaticPosition(8) :- mode(dorian).
modeChromaticPosition(10) :- mode(dorian).
modeChromaticPosition(11) :- mode(dorian).
lastChromaticPositionInMode(11) :- mode(dorian).


% Phrygian - white notes starting from E
% 1, 2, 4, 6, 8, 9, 11
modeChromaticPosition(1) :- mode(phrygian).
modeChromaticPosition(2) :- mode(phrygian).
modeChromaticPosition(4) :- mode(phrygian).
modeChromaticPosition(6) :- mode(phrygian).
modeChromaticPosition(8) :- mode(phrygian).
modeChromaticPosition(9) :- mode(phrygian).
modeChromaticPosition(11) :- mode(phrygian).
lastChromaticPositionInMode(11) :- mode(phrygian).

% Lydian F - F
% 1, 3, 5, 7, 8, 10, 12
modeChromaticPosition(1) :- mode(lydian).
modeChromaticPosition(3) :- mode(lydian).
modeChromaticPosition(5) :- mode(lydian).
modeChromaticPosition(7) :- mode(lydian).
modeChromaticPosition(8) :- mode(lydian).
modeChromaticPosition(10) :- mode(lydian).
modeChromaticPosition(12) :- mode(lydian).
lastChromaticPositionInMode(12) :- mode(lydian).


% Mixolydian G - G
% 1, 3, 5, 6, 8, 10, 11
modeChromaticPosition(1) :- mode(mixolydian).
modeChromaticPosition(3) :- mode(mixolydian).
modeChromaticPosition(5) :- mode(mixolydian).
modeChromaticPosition(6) :- mode(mixolydian).
modeChromaticPosition(8) :- mode(mixolydian).
modeChromaticPosition(10) :- mode(mixolydian).
modeChromaticPosition(11) :- mode(mixolydian).
lastChromaticPositionInMode(11) :- mode(mixolydian).

%% Every choosen note must be in the mode
#const err_nik="Choosen note not in mode".
reason(err_nik).
error(P,T,err_nik) :- chromaticPosition(C), choosenChromatic(P,T,C), not modeChromaticPosition(C). %tag


%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% progression.lp
%%
%% 03/11/06
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% Rules for the progression of all parts, melodic and harmonic

%% Note selection
%% may move by any reasonable amount (i.e. not just step)
%% are allowed the same note repeatedly


%% The number of parts is given by the style
%#domain part(P).
%#domain part(P1).
%#domain part(P2).


%% Time steps are given independantly for each part
partTime(P,1..TM) :- part(P), partTimeMax(P,TM). %changed

%% Each part can only play one note at a given time
%% This is needed so that partial pieces can be supplied.
 :- 2 { choosenNote(P,T,NN) : note(NN), rest(P,T) }, part(P), partTime(P,T). %tag

%% At every time step the note may change
%% It changes by stepping (moving one note in the scale)
%% or leaping (moving more than one note)
%% These can either be upwards or downwards
#count { 1:changes(P,T); 1:repeated(P,T);
    1:toRest(P,T); 1:fromRest(P,T);
    1:incorrectProgression(P,T) } = 1 :- part(P), partTime(P,T), partTimeMax(P,TM), T != TM. %changed
#count { 1:stepAt(P,T); 1:leapAt(P,T) } = 1 :- part(P), changes(P,T), partTimeMax(P,TM), T != TM. %changed
#count { 1:downAt(P,T);   1:upAt(P,T) } = 1 :- part(P), changes(P,T), partTimeMax(P,TM), T != TM. %changed

stepDown(P,T) :- part(P), stepAt(P,T), downAt(P,T). %changed
stepUp(P,T)   :- part(P), stepAt(P,T),   upAt(P,T). %changed

leapDown(P,T) :- part(P), leapAt(P,T), downAt(P,T). %changed
leapUp(P,T)   :- part(P), leapAt(P,T),   upAt(P,T). %changed

#const err_ip="Incorrect progression".
reason(err_ip).
error(P,T,err_ip) :- part(P), incorrectProgression(P,T). %changed

%% We start by moving from rest
fromRest(P,0) :- part(P).

%% Sanity checks so on the transition to and from rests
%% These are constraints rather than errors as fromRest / toRest
%% aren't part of the example format.
 :- rest(P,T), not repeated(P,T), not fromRest(P,T), part(P). %changed
 :- fromRest(P,T), not rest(P,T), T > 0, part(P). %changed


%% A step is to the next note of the mode
%% This assumes that for every given mode either N+1 or N+2 is in the mode
%% - but not both
%% Equivalently either N-1 or N-2 is in the mode
stepSize(2).
stepSize(1).
stepSize(-1).
stepSize(-2).
%#domain stepSize(S).
%#domain stepSize(S1).
%#domain stepSize(S2).
%#domain stepSize(S3).

%% If we step, we must pick an amount to step by
{ stepBy(P,T,SS) : stepSize(SS), SS < 0 } = 1 :- part(P), stepDown(P,T). %changed
{ stepBy(P,T,SS) : stepSize(SS), SS > 0 } = 1 :- part(P), stepUp(P,T). %changed
% (note that because of the structure of the mode
%  there should only be one option for each of these)

%% Leaps can only use consonant intervals
%% Connected - no jumps of over 12 chromatic steps
%% nor are dissonant leaps allowed (1), (6), (8), (9), (10), (11)
leapSize(CI) :- consonantInterval(CI), CI != 0.
leapSize(-CI) :- consonantInterval(CI), CI != 0.
leapSize(12).
leapSize(-12).
%#domain leapSize(L).
%#domain leapSize(L1).
%#domain leapSize(L2).
%#domain leapSize(L3).

%% If we leap then we must leap by a given amount
{ leapBy(P,T,LS) : leapSize(LS), LS < 0 } = 1 :- part(P), leapDown(P,T). %changed
{ leapBy(P,T,LS) : leapSize(LS), LS > 0 } = 1 :- part(P), leapUp(P,T). %changed


%% Make it so
choosenNote(P,T + 1,N + S) :- stepSize(S), part(P), choosenNote(P,T,N), stepAt(P,T),
                              stepBy(P,T,S), note(N + S). %changed
choosenNote(P,T + 1,N + L) :- leapSize(L), part(P), choosenNote(P,T,N), leapAt(P,T),
                              leapBy(P,T,L), note(N + L). %changed
choosenNote(P,T + 1,N) :- part(P), choosenNote(P,T,N), repeated(P,T). %changed

rest(P,T + 1) :- part(P), rest(P,T), repeated(P,T). %changed
rest(P,T + 1) :- part(P), toRest(P,T). %changed
{ choosenNote(P,T + 1,NN) : note(NN) } = 1 :- part(P), fromRest(P,T). %changed
{ choosenNote(P,1,NN)     : note(NN) } = 1 :- part(P), fromRest(P,0). %changed

%% In some cases we only care about the chromatic position of a part, not the note
choosenChromatic(P,T,C) :- note(N), part(P), chromaticPosition(C), choosenNote(P,T,N), chromatic(N,C). %changed


%% Notes must be within the given range
%% Note this is not an 'error' as it can only be given by the program
%% not the user (assuming piece inputs are just a set of notes)
%% plus having notes 'outside' the usual range cause problems
%% with multiple simmultaneous notes.
 :- stepSize(S), part(P), note(N), choosenNote(P,T,N), stepAt(P,T), stepBy(P,T,S), not note(N + S). %changed
 :- leapSize(L), part(P), note(N), choosenNote(P,T,N), leapAt(P,T), leapBy(P,T,L), not note(N + L). %changed


%% Work out the range of the part
notePlayed(P,N) :- part(P), note(N), choosenNote(P,T,N). %changed

highestNote(P,N) :- part(P), note(N), notePlayed(P,N), not lowerThanHighestNote(P,N). %changed
lowerThanHighestNote(P,N-1) :- part(P), note(N), highestNote(P,N). %changed
lowerThanHighestNote(P,N-1) :- part(P), note(N), lowerThanHighestNote(P,N). %changed

lowestNote(P,N) :- part(P), note(N), notePlayed(P,N), not higherThanLowestNote(P,N).
higherThanLowestNote(P,N+1) :- part(P), note(N), lowestNote(P,N).
higherThanLowestNote(P,N+1) :- part(P), note(N), higherThanLowestNote(P,N).


%% Total range must not be more than 2 octaves
#const err_ro="Range over two octaves".
reason(err_ro).
error(P,TM,err_ro) :- part(P), note(N1), note(N2), lowestNote(P,N1), highestNote(P,N2), N1 + 24 < N2, partTimeMax(P,TM). %changed



%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% melody.lp
%%
%% 03/11/06
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% The rules for melodic parts


%% These rules only apply to melodic parts
%#domain melodicPart(MP).

%% Melodic parts are not allowed to repeat notes
#const err_nrmp="No repeated notes in melodic parts".
reason(err_nrmp).
error(MP,T,err_nrmp) :- melodicPart(MP), repeated(MP,T). %changed


%% Last interval is major or minor second (respectively two or one step)
%% I.E. It cannot be a leap
#const err_lins="Last interval is not a second".
reason(err_lins).
error(MP,TM-1,err_lins) :- melodicPart(MP), leapAt(MP,TM-1), partTimeMax(MP,TM). %changed


%% A leap of an octave is only allowed from the fundamental.
#const err_olnf="Leap of an octave from a note other than the fundamental".
reason(err_olnf).
error(MP,T,err_olnf) :- melodicPart(MP), leapBy(MP,T,12), not choosenChromatic(MP,T,1). %changed
error(MP,T,err_olnf) :- melodicPart(MP), leapBy(MP,T,-12), not choosenChromatic(MP,T,1). %changed


%% No two consecutive jumps that `cancel'
#const err_cl="Leaps cancel".
reason(err_cl).
error(MP,T,err_cl) :- melodicPart(MP),leapSize(L), leapBy(MP,T,L), leapBy(MP,T + 1,-L), partTime(MP,T+1). %changed


%% Dissonant contour
%% distance between lowest and highest note of melody - should not be a dissonant interval
#const err_dc="Dissonant contour".
reason(err_dc).
error(MP,TM,err_dc) :-  melodicPart(MP), note(N1), note(N2), chromaticPosition(C1), chromaticPosition(C2), lowestNote(MP,N1), highestNote(MP,N2),
                       chromatic(N1,C1),  chromatic(N2,C2),
                       not consonant(C1,C2), N1 < N2, partTimeMax(MP,TM). %changed



%% No tri-tones
%% A tritone occurs when a pair of notes, one time step apart differ
%% in tone by 6 semitones.
#const err_tt="Tri-tone".
reason(err_tt).
error(MP,T,err_tt) :- melodicPart(MP), note(N1), choosenNote(MP,T,N1), choosenNote(MP,T+2,N1+6).
error(MP,T,err_tt) :- melodicPart(MP), note(N1), choosenNote(MP,T,N1), choosenNote(MP,T+2,N1-6).





%% Impulse
%% Stepwise linear progression creates impulse
%% Leaps create impulse - using the notes inbetween resolves this
downwardImpulse(MP,T+1) :- melodicPart(MP), leapDown(MP,T), partTime(MP,T+1). %changed
downwardImpulse(MP,T+3) :- melodicPart(MP), stepDown(MP,T+2), stepDown(MP,T+1),
                           stepDown(MP,T), partTime(MP,T+3). %changed

upwardImpulse(MP,T+1) :- melodicPart(MP), leapUp(MP,T), partTime(MP,T+1). %changed
upwardImpulse(MP,T+3) :- melodicPart(MP), stepUp(MP,T+2), stepUp(MP,T+1),
                         stepUp(MP,T), partTime(MP,T+3). %changed


%% Resolution is in the oppersite direction to impulse
#const err_inr="Impulse not resolved".
reason(err_inr).
error(MP,T,err_inr) :- melodicPart(MP), downwardImpulse(MP,T), downAt(MP,T). %changed
error(MP,T,err_inr) :- melodicPart(MP), upwardImpulse(MP,T), upAt(MP,T). %changed


%% After a leap must use everything inbetween 
%% can jump again but it must be inside the range
#const err_ns="Note skipped".
reason(err_ns).
error(MP,TM,err_ns) :-  melodicPart(MP), note(N), chromaticPosition(C), not notePlayed(MP,N),
                        lowerThanHighestNote(MP,N), higherThanLowestNote(MP,N),
                        chromatic(N,C), modeChromaticPosition(C),
                        partTimeMax(P,TM).




%% We have a window in which repetition isn't allowed
repetitionWindow(8).
%#domain repetitionWindow(RW).

%% Shouldn't repeat simple patterns of progression
%% (things in mode) 0 - 2 - 1, 1 - 3 - 2, 
%% A pattern is a minimum of 3 notes and a maximum of melodyLength/2 notes
#const err_rp="Repeated pattern".
reason(err_rp).
error(MP,T1,err_rp) :- melodicPart(MP), stepSize(S1), stepSize(S2), stepBy(MP,T1,S1), stepBy(MP,T1 + 1,S2),
                       stepBy(MP,T2,S1), stepBy(MP,T2 + 1,S2),
                       T1 + 1 < T2, T2 < T1 + 2 + RW, repetitionWindow(RW). %changed
error(MP,T1,err_rp) :- melodicPart(MP), stepSize(S1), leapSize(L2), stepBy(MP,T1,S1), leapBy(MP,T1 + 1,L2),
                       stepBy(MP,T2,S1), leapBy(MP,T2 + 1,L2),
                       T1 + 1 < T2, T2 < T1 + 2 + RW, repetitionWindow(RW). %changed
error(MP,T1,err_rp) :- melodicPart(MP), leapSize(L1), stepSize(S2), leapBy(MP,T1,L1), stepBy(MP,T1 + 1,S2),
                       leapBy(MP,T2,L1), stepBy(MP,T2 + 1,S2),
                       T1 + 1 < T2, T2 < T1 + 2 + RW, repetitionWindow(RW). %changed
error(MP,T1,err_rp) :- melodicPart(MP), leapSize(L1), leapSize(L2), leapBy(MP,T1,L1), leapBy(MP,T1 + 1,L2),
                       leapBy(MP,T2,L1), leapBy(MP,T2 + 1,L2),
                       T1 + 1 < T2, T2 < T1 + 2 + RW, repetitionWindow(RW). %changed


%% No repetition of two or more notes
#const err_rn="Repeated notes".
reason(err_rn).

error(MP,T1,err_rn) :- melodicPart(MP), stepSize(S1), choosenNote(MP,T1,N), stepBy(MP,T1,S1),
                       choosenNote(MP,T2,N), stepBy(MP,T2,S1),
                       T1 + 1 < T2, T2 < T1 + 2 + RW, repetitionWindow(RW). %changed
error(MP,T1,err_rn) :- melodicPart(MP), note(N), choosenNote(MP,T1,N), leapBy(MP,T1,L1),
                       choosenNote(MP,T2,N), leapBy(MP,T2,L1),
                       T1 + 1 < T2, T2 < T1 + 2 + RW, repetitionWindow(RW). %changed


%% Split melodies occur when the even / odd notes form separate melodies.
%% A leap (in the same direction) are not allowed to be repeated at T+2.
%% Steps are only allowed if the intermediate movement is not a step
%% in the oppersite direction.
#const err_sm="Split melody".
reason(err_sm).

error(MP,T,err_sm) :- melodicPart(MP), leapSize(L), leapBy(MP,T,L), leapBy(MP,T+2,L). %changed
error(MP,T,err_sm) :- melodicPart(MP), stepSize(S1), stepSize(S2), stepBy(MP,T,S1), stepBy(MP,T+1,S2), stepBy(MP,T+2,S1),
                      S1 > 0, S2 < 0. %changed
error(MP,T,err_sm) :- melodicPart(MP), stepSize(S1), stepSize(S2), stepBy(MP,T,S1), stepBy(MP,T+1,S2), stepBy(MP,T+2,S1),
                      S1 < 0, S2 > 0. %changed
%% Harmonic rules are not needed for one part
%% Not chordal for the obvious reason


%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% monorhythmic.lp
%%
%% 02/02/10
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% If the rhythm option is not used, this gives default definitions
%% of rhythmic concepts.

rhythm(0).
%% Parts overlap if their timesteps match
noteOverlap(P1,T,P2,T) :- part(P1), part(P2), not rhythm(1), P1 != P2,
                          partTime(P1,T), partTime(P2,T).

%% Every time step is a possible chord
possibleChord(PC) :- part(P), partTime(P,PC).

%% Thus the progression is obvious
nextPossibleChord(PC,PC+1) :- possibleChord(PC), possibleChord(PC+1).
lastPossibleChord(PC) :- not possibleChord(PC+1), possibleChord(PC).

%% With the corresponding notes in each chord
noteInPossibleChord(P,PC,PC) :- part(P), partTime(P,PC), possibleChord(PC).



%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% compose.lp
%%
%% Martin Brain
%% mjb@cs.bath.ac.uk
%% 27/03/08
%%
%% Uses the melodic and harmonic rules to generate valid pieces of music

%#hide.

mode(K) :- mode(K).
#show mode/1.

% #show style(C).
style(C) :- style(C).
#show style/1.

% #show part(P).
part(P) :- part(P).
#show part/1.

% #show partTime(P,T).
partTime(P,T) :- partTime(P,T).
#show partTime/2.
% #show partTimeMax(P,TM).
partTimeMax(P,TM) :- partTimeMax(P,TM).
#show partTimeMax/2.

% #show choosenNote(P,T,N).
choosenNote(P,T,N) :- choosenNote(P,T,N).
#show choosenNote/3.
% #show rest(P,T).
rest(P,T) :- rest(P,T).
#show rest/2.

% #show leapBy(P,T,L).
leapBy(P,T,L) :- leapBy(P,T,L).
#show leapBy/3.
% #show stepBy(P,T,S).
stepBy(P,T,S) :- stepBy(P,T,S).
#show stepBy/3.
% #show repeated(P,T).
repeated(P,T) :- repeated(P,T).
#show repeated/2.
% #show incorrectProgression(P,T).
incorrectProgression(P,T) :- incorrectProgression(P,T).
#show incorrectProgression/2.
% #show toRest(P,T).
toRest(P,T) :- toRest(P,T).
#show toRest/2.
% #show fromRest(P,T).
fromRest(P,T) :- fromRest(P,T).
#show fromRest/2.

% #show chordal(B).
chordal(B) :- chordal(B).
#show chordal/1.
% #show chord(T,TR).
chord(T,TR) :- chord(T,TR).
#show chord/2.
% #show chordPosition(T,TP).
chordPosition(T,TP) :- chordPosition(T,TP).
#show chordPosition/2.
% #show cadence(T,C).
cadence(T,C) :- cadence(T,C).
#show cadence/2.

% No errors are allowed
% #domain reason(R).
  :- reason(R), error(P,T,R).