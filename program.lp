%% File autogenerated by programBuilder.pl, part of the Anton composition system
%% Command line arguments : --task=compose --mode=minor --time=10

partTimeMax(P,10) :- part(P), P >= 1.
mode(minor).
style(solo).

%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% solo.lp
%%
%% 29/03/07
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% Rules for composing / analysising melodies for a single instrument

%% This is a solo
style(solo).

%% There is only one part...
part(1).

%% ... and it is melodic
melodicPart(1).

%% We need a range of up to 2 octaves (24 steps), thus need 24 notes above and below the start / end
#const soloBottomNote=1.
#const soloTopNote=49.
note(soloBottomNote..soloTopNote).
bottomNote(soloBottomNote).
topNote(soloTopNote).

%% Start on the (middle) fundamental, a 5th above or a 5th below
%% (5 chromatic steps down or 7 up) ...
#const err_isn="Incorrect starting note".
reason(err_isn).
error(1,1,err_isn) :- not choosenNote(1,1,20), not choosenNote(1,1,25),
                      not choosenNote(1,1,32).

%% ... and finish on the fundamental
#const err_snff="Must finish on the fundamental".
reason(err_snff).
error(1,TM,err_snff) :- choosenNote(1,TM,N), chromatic(N,C), C != 1,
                       partTimeMax(1,TM).

%% No rests
#const err_nrfw="No rest for the wicked".
reason(err_nrfw).
error(P,T,err_nrfw) :- rest(P,T).



%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% notes.lp
%%
%% 13/05/09
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% General background rules on notes and intervals

%% Model in chromatic steps - 12 notes in an octave
%% needed for major and minor
chromaticPosition(1..12).
#domain chromaticPosition(C).
#domain chromaticPosition(C1).
#domain chromaticPosition(C2).

%% The correspondance between number and note name is given by the key
%% and is applied at the synthesis step and is thus not modelled.
%% The number of notes depends on the style of the piece
#domain note(N).
#domain note(N1).
#domain note(N2).

%% Map notes to their chromatic position
chromatic(N,N mod 12) :- (N mod 12) != 0.
chromatic(N,12) :- (N mod 12) == 0.

%% Intervals between notes are refered to as consonant if they are of a given distance:
%% unison (0), minor third (3), major third (4), fourth (5), perfect fifth (7) (mod 12)
consonantInterval(0).
consonantInterval(3).
consonantInterval(4).
consonantInterval(5).
consonantInterval(7).
#domain consonantInterval(CI).

%% Pairs of chromatic positions that are consonant
consonant(C1,C2) :- chromatic(N,C1), chromatic(N + CI, C2).

%% The interval between two notes
%% Note there are two possible definitions of modulo distance
%% Thus it is important that the first chromatic position is
%% that of the higher note.
chromaticInterval(C1,C2,C1 - C2) :- C1 > C2.
chromaticInterval(C1,C2,(C1 + 12) - C2) :- C1 < C2.
chromaticInterval(C,C,0).

possibleChromaticInterval(0..11).
#domain possibleChromaticInterval(D).


%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% modes.lp
%%
%% 29/03/07
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% A description of the various modes/keys the system can use

%% A mode is severn notes from the 12
%% (well, nine notes if it is a minor scale).
%% Must have one chromatic step between top of scale and fundamental.
%% Only pick from valid notes from mode.

%% mode is user defined.

% C major is C, D, E, F, G,  A,  B
% I.E.       1, 3, 5, 6, 8, 10, 12
modeChromaticPosition(1) :- mode(major).
modeChromaticPosition(3) :- mode(major).
modeChromaticPosition(5) :- mode(major).
modeChromaticPosition(6) :- mode(major).
modeChromaticPosition(8) :- mode(major).
modeChromaticPosition(10) :- mode(major).
modeChromaticPosition(12) :- mode(major).
lastChromaticPositionInMode(12) :- mode(major).

% C minor downwards is C, D, E^{\flat}, F, G, A^{\flat}, B^{\flat}, C
% I.E.                 1, 3, 4,         6, 8, 9,         11

% C minor upwards is C, D, E^{\flat}, F, G,  A,  B, C
% I.E.               1, 3, 4,         6, 8, 10, 12
modeChromaticPosition(1) :- mode(minor).
modeChromaticPosition(3) :- mode(minor).
modeChromaticPosition(4) :- mode(minor).
modeChromaticPosition(6) :- mode(minor).
modeChromaticPosition(8) :- mode(minor).
modeChromaticPosition(9) :- mode(minor).
modeChromaticPosition(10) :- mode(minor).
modeChromaticPosition(11) :- mode(minor).
modeChromaticPosition(12) :- mode(minor).
lastChromaticPositionInMode(11) :- mode(minor).
lastChromaticPositionInMode(12) :- mode(minor).


% The last two notes of a minor scale are dependant on direction
% upwards the last two are 10,12
% downwards the last two are 9,11
% You must be both progressing in the correct direction and continuing to
% progress in that directsion
#const err_imm="Invalid move in a minor key".
reason(err_imm).
error(P,T,err_imm) :- choosenChromatic(P,T,9), upAt(P,T - 1),
                      mode(minor), partTime(P,T - 1).
error(P,T,err_imm) :- choosenChromatic(P,T,11), upAt(P,T - 1),
                      mode(minor), partTime(P,T - 1).
error(P,T,err_imm) :- choosenChromatic(P,T,10), downAt(P,T - 1),
                      mode(minor), partTime(P,T - 1).
error(P,T,err_imm) :- choosenChromatic(P,T,12), downAt(P,T - 1),
                      mode(minor), partTime(P,T - 1).

error(P,T,err_imm) :- choosenChromatic(P,T,11), upAt(P,T), mode(minor).
error(P,T,err_imm) :- choosenChromatic(P,T,10), downAt(P,T), mode(minor).
error(P,T,err_imm) :- choosenChromatic(P,T,12), downAt(P,T), mode(minor).

%% 9 is an exception, you are allowed to move up, but not to 10 or 12
%error(P,T,err_imm) :- choosenChromatic(P,T,9), upAt(P,T), mode(minor).

error(P,T,err_imm) :- choosenChromatic(P,T,9), choosenChromatic(P,T+1,10), mode(minor).
error(P,T,err_imm) :- choosenChromatic(P,T,9), choosenChromatic(P,T+1,12), mode(minor).



%% Note that in some contexts C B C may be acceptable.
%%  B^{\flat} C B C is not one of them.


% Additionally, there are some restrictions
% Can't go from position (12,4), (10,4), (4,12), (4,10)
#const err_ijm="Invalid jump in a minor modeChromaticPosition".
reason(err_ijm).
error(P,T,err_ijm) :- choosenChromatic(P,T,12), choosenChromatic(P,T+1,4), mode(minor).
error(P,T,err_ijm) :- choosenChromatic(P,T,10), choosenChromatic(P,T+1,4), mode(minor).
error(P,T,err_ijm) :- choosenChromatic(P,T,4), choosenChromatic(P,T+1,10), mode(minor).
error(P,T,err_ijm) :- choosenChromatic(P,T,4), choosenChromatic(P,T+1,12), mode(minor).


% JPff suggests that B must also always resolve to C
#const err_mmmr="Problem with minor mode melodic resolution".
reason(err_mmmr).
error(P,T,err_mmmr) :- choosenChromatic(P,T,12), not choosenChromatic(P,T+1,1),
                       mode(minor), partTime(P,T+1).

% There are several restrictions on harmonic combinations in minor mode
% (12,9) = (12,21) and (12,4) = (12,16) aren't allowed
#const err_imh="Invalid minor harmonic combination".
reason(err_imh).
error(P1,T,err_imh) :- choosenChromatic(P1,T,12), choosenChromatic(P2,T,9), P1 < P2.
error(P1,T,err_imh) :- choosenChromatic(P1,T,9), choosenChromatic(P2,T,12), P1 < P2.
error(P1,T,err_imh) :- choosenChromatic(P1,T,12), choosenChromatic(P2,T,4), P1 < P2.
error(P1,T,err_imh) :- choosenChromatic(P1,T,4), choosenChromatic(P2,T,12), P1 < P2.



% Dorian - white notes starting from D
% I.E.       1, 3, 4, 6, 8, 10, 11
modeChromaticPosition(1) :- mode(dorian).
modeChromaticPosition(3) :- mode(dorian).
modeChromaticPosition(4) :- mode(dorian).
modeChromaticPosition(6) :- mode(dorian).
modeChromaticPosition(8) :- mode(dorian).
modeChromaticPosition(10) :- mode(dorian).
modeChromaticPosition(11) :- mode(dorian).
lastChromaticPositionInMode(11) :- mode(dorian).


% Phrygian - white notes starting from E
% 1, 2, 4, 6, 8, 9, 11
modeChromaticPosition(1) :- mode(phrygian).
modeChromaticPosition(2) :- mode(phrygian).
modeChromaticPosition(4) :- mode(phrygian).
modeChromaticPosition(6) :- mode(phrygian).
modeChromaticPosition(8) :- mode(phrygian).
modeChromaticPosition(9) :- mode(phrygian).
modeChromaticPosition(11) :- mode(phrygian).
lastChromaticPositionInMode(11) :- mode(phrygian).

% Lydian F - F
% 1, 3, 5, 7, 8, 10, 12
modeChromaticPosition(1) :- mode(lydian).
modeChromaticPosition(3) :- mode(lydian).
modeChromaticPosition(5) :- mode(lydian).
modeChromaticPosition(7) :- mode(lydian).
modeChromaticPosition(8) :- mode(lydian).
modeChromaticPosition(10) :- mode(lydian).
modeChromaticPosition(12) :- mode(lydian).
lastChromaticPositionInMode(12) :- mode(lydian).


% Mixolydian G - G
% 1, 3, 5, 6, 8, 10, 11
modeChromaticPosition(1) :- mode(mixolydian).
modeChromaticPosition(3) :- mode(mixolydian).
modeChromaticPosition(5) :- mode(mixolydian).
modeChromaticPosition(6) :- mode(mixolydian).
modeChromaticPosition(8) :- mode(mixolydian).
modeChromaticPosition(10) :- mode(mixolydian).
modeChromaticPosition(11) :- mode(mixolydian).
lastChromaticPositionInMode(11) :- mode(mixolydian).

%% Every choosen note must be in the mode
#const err_nik="Choosen note not in mode".
reason(err_nik).
error(P,T,err_nik) :- choosenChromatic(P,T,C), not modeChromaticPosition(C).


%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% progression.lp
%%
%% 03/11/06
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% Rules for the progression of all parts, melodic and harmonic

%% Note selection
%% may move by any reasonable amount (i.e. not just step)
%% are allowed the same note repeatedly


%% The number of parts is given by the style
#domain part(P).
#domain part(P1).
#domain part(P2).


%% Time steps are given independantly for each part
partTime(P,1..TM) :- partTimeMax(P,TM).

%% Each part can only play one note at a given time
%% This is needed so that partial pieces can be supplied.
 :- 2 { choosenNote(P,T,NN) : note(NN), rest(P,T) }, partTime(P,T).

%% At every time step the note may change
%% It changes by stepping (moving one note in the scale)
%% or leaping (moving more than one note)
%% These can either be upwards or downwards
1 { changes(P,T), repeated(P,T),
    toRest(P,T), fromRest(P,T),
    incorrectProgression(P,T) } 1 :- partTime(P,T), partTimeMax(P,TM), T != TM.
1 { stepAt(P,T), leapAt(P,T) } 1 :- changes(P,T), partTimeMax(P,TM), T != TM.
1 { downAt(P,T),   upAt(P,T) } 1 :- changes(P,T), partTimeMax(P,TM), T != TM.

stepDown(P,T) :- stepAt(P,T), downAt(P,T).
stepUp(P,T)   :- stepAt(P,T),   upAt(P,T).

leapDown(P,T) :- leapAt(P,T), downAt(P,T).
leapUp(P,T)   :- leapAt(P,T),   upAt(P,T).

#const err_ip="Incorrect progression".
reason(err_ip).
error(P,T,err_ip) :- incorrectProgression(P,T).

%% We start by moving from rest
fromRest(P,0).

%% Sanity checks so on the transition to and from rests
%% These are constraints rather than errors as fromRest / toRest
%% aren't part of the example format.
 :- rest(P,T), not repeated(P,T), not fromRest(P,T).
 :- fromRest(P,T), not rest(P,T), T > 0.


%% A step is to the next note of the mode
%% This assumes that for every given mode either N+1 or N+2 is in the mode
%% - but not both
%% Equivalently either N-1 or N-2 is in the mode
stepSize(2).
stepSize(1).
stepSize(-1).
stepSize(-2).
#domain stepSize(S).
#domain stepSize(S1).
#domain stepSize(S2).
#domain stepSize(S3).

%% If we step, we must pick an amount to step by
1 { stepBy(P,T,SS) : stepSize(SS) : SS < 0 } 1 :- stepDown(P,T).
1 { stepBy(P,T,SS) : stepSize(SS) : SS > 0 } 1 :- stepUp(P,T).
% (note that because of the structure of the mode
%  there should only be one option for each of these)

%% Leaps can only use consonant intervals
%% Connected - no jumps of over 12 chromatic steps
%% nor are dissonant leaps allowed (1), (6), (8), (9), (10), (11)
leapSize(CI) :- CI != 0.
leapSize(-CI) :- CI != 0.
leapSize(12).
leapSize(-12).
#domain leapSize(L).
#domain leapSize(L1).
#domain leapSize(L2).
#domain leapSize(L3).

%% If we leap then we must leap by a given amount
1 { leapBy(P,T,LS) : leapSize(LS) : LS < 0 } 1 :- leapDown(P,T).
1 { leapBy(P,T,LS) : leapSize(LS) : LS > 0 } 1 :- leapUp(P,T).


%% Make it so
choosenNote(P,T + 1,N + S) :- choosenNote(P,T,N), stepAt(P,T),
                              stepBy(P,T,S), note(N + S).
choosenNote(P,T + 1,N + L) :- choosenNote(P,T,N), leapAt(P,T),
                              leapBy(P,T,L), note(N + L).
choosenNote(P,T + 1,N) :- choosenNote(P,T,N), repeated(P,T).

rest(P,T + 1) :- rest(P,T), repeated(P,T).
rest(P,T + 1) :- toRest(P,T).
1 { choosenNote(P,T + 1,NN) : note(NN) } 1 :- fromRest(P,T).
1 { choosenNote(P,1,NN)     : note(NN) } 1 :- fromRest(P,0).

%% In some cases we only care about the chromatic position of a part, not the note
choosenChromatic(P,T,C) :- choosenNote(P,T,N), chromatic(N,C).


%% Notes must be within the given range
%% Note this is not an 'error' as it can only be given by the program
%% not the user (assuming piece inputs are just a set of notes)
%% plus having notes 'outside' the usual range cause problems
%% with multiple simmultaneous notes.
 :- choosenNote(P,T,N), stepAt(P,T), stepBy(P,T,S), not note(N + S).
 :- choosenNote(P,T,N), leapAt(P,T), leapBy(P,T,L), not note(N + L).


%% Work out the range of the part
notePlayed(P,N) :- choosenNote(P,T,N).

highestNote(P,N) :- notePlayed(P,N), not lowerThanHighestNote(P,N).
lowerThanHighestNote(P,N-1) :- highestNote(P,N).
lowerThanHighestNote(P,N-1) :- lowerThanHighestNote(P,N).

lowestNote(P,N) :- notePlayed(P,N), not higherThanLowestNote(P,N).
higherThanLowestNote(P,N+1) :- lowestNote(P,N).
higherThanLowestNote(P,N+1) :- higherThanLowestNote(P,N).


%% Total range must not be more than 2 octaves
#const err_ro="Range over two octaves".
reason(err_ro).
error(P,TM,err_ro) :- lowestNote(P,N1), highestNote(P,N2), N1 + 24 < N2, partTimeMax(P,TM).



%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% melody.lp
%%
%% 03/11/06
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% The rules for melodic parts


%% These rules only apply to melodic parts
#domain melodicPart(MP).

%% Melodic parts are not allowed to repeat notes
#const err_nrmp="No repeated notes in melodic parts".
reason(err_nrmp).
error(MP,T,err_nrmp) :- repeated(MP,T).


%% Last interval is major or minor second (respectively two or one step)
%% I.E. It cannot be a leap
#const err_lins="Last interval is not a second".
reason(err_lins).
error(MP,TM-1,err_lins) :- leapAt(MP,TM-1), partTimeMax(MP,TM).


%% A leap of an octave is only allowed from the fundamental.
#const err_olnf="Leap of an octave from a note other than the fundamental".
reason(err_olnf).
error(MP,T,err_olnf) :- leapBy(MP,T,12), not choosenChromatic(MP,T,1).
error(MP,T,err_olnf) :- leapBy(MP,T,-12), not choosenChromatic(MP,T,1).


%% No two consecutive jumps that `cancel'
#const err_cl="Leaps cancel".
reason(err_cl).
error(MP,T,err_cl) :- leapBy(MP,T,L), leapBy(MP,T + 1,-L), partTime(MP,T+1).


%% Dissonant contour
%% distance between lowest and highest note of melody - should not be a dissonant interval
#const err_dc="Dissonant contour".
reason(err_dc).
error(MP,TM,err_dc) :- lowestNote(MP,N1), highestNote(MP,N2),
                       chromatic(N1,C1),  chromatic(N2,C2),
                       not consonant(C1,C2), N1 < N2, partTimeMax(MP,TM).



%% No tri-tones
%% A tritone occurs when a pair of notes, one time step apart differ
%% in tone by 6 semitones.
#const err_tt="Tri-tone".
reason(err_tt).
error(MP,T,err_tt) :- choosenNote(MP,T,N1), choosenNote(MP,T+2,N1+6).
error(MP,T,err_tt) :- choosenNote(MP,T,N1), choosenNote(MP,T+2,N1-6).





%% Impulse
%% Stepwise linear progression creates impulse
%% Leaps create impulse - using the notes inbetween resolves this
downwardImpulse(MP,T+1) :- leapDown(MP,T), partTime(MP,T+1).
downwardImpulse(MP,T+3) :- stepDown(MP,T+2), stepDown(MP,T+1),
                           stepDown(MP,T), partTime(MP,T+3).

upwardImpulse(MP,T+1) :- leapUp(MP,T), partTime(MP,T+1).
upwardImpulse(MP,T+3) :- stepUp(MP,T+2), stepUp(MP,T+1),
                         stepUp(MP,T), partTime(MP,T+3).


%% Resolution is in the oppersite direction to impulse
#const err_inr="Impulse not resolved".
reason(err_inr).
error(MP,T,err_inr) :- downwardImpulse(MP,T), downAt(MP,T).
error(MP,T,err_inr) :- upwardImpulse(MP,T), upAt(MP,T).


%% After a leap must use everything inbetween 
%% can jump again but it must be inside the range
#const err_ns="Note skipped".
reason(err_ns).
error(MP,TM,err_ns) :-  not notePlayed(MP,N),
                        lowerThanHighestNote(MP,N), higherThanLowestNote(MP,N),
                        chromatic(N,C), modeChromaticPosition(C),
                        partTimeMax(P,TM).




%% We have a window in which repetition isn't allowed
repetitionWindow(8).
#domain repetitionWindow(RW).

%% Shouldn't repeat simple patterns of progression
%% (things in mode) 0 - 2 - 1, 1 - 3 - 2, 
%% A pattern is a minimum of 3 notes and a maximum of melodyLength/2 notes
#const err_rp="Repeated pattern".
reason(err_rp).
error(MP,T1,err_rp) :- stepBy(MP,T1,S1), stepBy(MP,T1 + 1,S2),
                       stepBy(MP,T2,S1), stepBy(MP,T2 + 1,S2),
                       T1 + 1 < T2, T2 < T1 + 2 + RW.
error(MP,T1,err_rp) :- stepBy(MP,T1,S1), leapBy(MP,T1 + 1,L2),
                       stepBy(MP,T2,S1), leapBy(MP,T2 + 1,L2),
                       T1 + 1 < T2, T2 < T1 + 2 + RW.
error(MP,T1,err_rp) :- leapBy(MP,T1,L1), stepBy(MP,T1 + 1,S2),
                       leapBy(MP,T2,L1), stepBy(MP,T2 + 1,S2),
                       T1 + 1 < T2, T2 < T1 + 2 + RW.
error(MP,T1,err_rp) :- leapBy(MP,T1,L1), leapBy(MP,T1 + 1,L2),
                       leapBy(MP,T2,L1), leapBy(MP,T2 + 1,L2),
                       T1 + 1 < T2, T2 < T1 + 2 + RW.


%% No repetition of two or more notes
#const err_rn="Repeated notes".
reason(err_rn).

error(MP,T1,err_rn) :- choosenNote(MP,T1,N), stepBy(MP,T1,S1),
                       choosenNote(MP,T2,N), stepBy(MP,T2,S1),
                       T1 + 1 < T2, T2 < T1 + 2 + RW.
error(MP,T1,err_rn) :- choosenNote(MP,T1,N), leapBy(MP,T1,L1),
                       choosenNote(MP,T2,N), leapBy(MP,T2,L1),
                       T1 + 1 < T2, T2 < T1 + 2 + RW.


%% Split melodies occur when the even / odd notes form separate melodies.
%% A leap (in the same direction) are not allowed to be repeated at T+2.
%% Steps are only allowed if the intermediate movement is not a step
%% in the oppersite direction.
#const err_sm="Split melody".
reason(err_sm).

error(MP,T,err_sm) :- leapBy(MP,T,L), leapBy(MP,T+2,L).
error(MP,T,err_sm) :- stepBy(MP,T,S1), stepBy(MP,T+1,S2), stepBy(MP,T+2,S1),
                      S1 > 0, S2 < 0.
error(MP,T,err_sm) :- stepBy(MP,T,S1), stepBy(MP,T+1,S2), stepBy(MP,T+2,S1),
                      S1 < 0, S2 > 0.
%% Harmonic rules are not needed for one part
%% Not chordal for the obvious reason


%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% monorhythmic.lp
%%
%% 02/02/10
%%
%% Concepts by Georg Boenn, gboenn@glam.ac.uk
%% Encoding by Martin Brain, mjb@cs.bath.ac.uk
%%
%% If the rhythm option is not used, this gives default definitions
%% of rhythmic concepts.


%% Parts overlap if their timesteps match
noteOverlap(P1,T,P2,T) :- not rhythm(1), P1 != P2,
                          partTime(P1,T), partTime(P2,T).

%% Every time step is a possible chord
possibleChord(PC) :- partTime(P,PC).

%% Thus the progression is obvious
nextPossibleChord(PC,PC+1) :- possibleChord(PC), possibleChord(PC+1).
lastPossibleChord(PC) :- not possibleChord(PC+1), possibleChord(PC).

%% With the corresponding notes in each chord
noteInPossibleChord(P,PC,PC) :- partTime(P,PC), possibleChord(PC).



%% Copyright (C) 2010 Martin Brain and Georg Boenn
%% 
%% This program is free software; you can redistribute it and/or
%% modify it under the terms of the GNU General Public License
%% as published by the Free Software Foundation; either version 2
%% of the License, or (at your option) any later version.
%% 
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%% 
%% You should have received a copy of the GNU General Public License
%% along with this program; if not, write to the Free Software
%% Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
%% 02110-1301, USA.


%% compose.lp
%%
%% Martin Brain
%% mjb@cs.bath.ac.uk
%% 27/03/08
%%
%% Uses the melodic and harmonic rules to generate valid pieces of music

#hide.

#show mode(K).
#show style(C).
#show part(P).
#show partTime(P,T).
#show partTimeMax(P,TM).

#show choosenNote(P,T,N).
#show rest(P,T).

#show leapBy(P,T,L).
#show stepBy(P,T,S).
#show repeated(P,T).
#show incorrectProgression(P,T).
#show toRest(P,T).
#show fromRest(P,T).

#show chordal(B).
#show chord(T,TR).
#show chordPosition(T,TP).
#show cadence(T,C).


% No errors are allowed
#domain reason(R).
 :- error(P,T,R).
